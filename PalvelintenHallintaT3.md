# *Palvelinten hallinta tehtävä 3. Versionhallinta, markdown,  salt*

## a) Git ja Markdown
Tässä tehtävässä oli määrä harjoitella paitsi markdownin käyttöä myös versionhallintaa gitin ja githubin avulla. Githubista on hieman kokemusta, lähinnä tietokantakurssilta, markdownista ei oikeastaan kokoemusta ole. Tehtävässä päästiin tavallaan alkuun jo tunnilla,
 kun kävimme läpi git:in peruskomentoja, ja katsoimme alustavasti githubia. Itseltäni löytyikin jo valmiiksi github tili, johon loin repositorion tätä tehtävää varten. Ohjeita tehtävää varten katselin pääosin Tero Karvisen [sivuilta](http://terokarvinen.com/2016/publish-your-project-with-github/). ALkutoimenpiteissä seurasin sivun ohejita pilkulleen, mutta vaihdoin salansananmuistamisen ajan hieman pidemmäksi, komentona siis `<$ git config --global credential.helper "cache --timeout=7200">`, jossa 7200 = sekunnit jotka salasana on voimassa. Näiden tehtävien kuvat löytyvät githubista omina tiedostoinaan! 

Tärkää tässä on siis ymmärtää git:in perustoiminto. Itse tein siinä järjesteyksessä, että loin aluksi repositorion, jonka cloonasin git clone -komennolla omaan, Xubuntu kotikansiooni. Loin sinne tiedostot jotka halusin luoda, testitiedoston, ja tämän palautustiedoston .md päätteiillä, jotta github tunnistaa nämä markdown -muotoiluiksi. Kun muutokset on tehty, ne lisätään ikäänkuin jonoon git add komennolla, git commit vahvistaa että haluan lähettää tiedostot. Tiedostot ovat kuitenkin toistaiseksi vain paikallisesti taltioitu Git push komennon antaminen syöttää tiedostot verkkoon, sen jälkeen kun on syöttänyt tunnuksensa. Sivuilta löytyikin ritiramssu sitä varalta, että haluaa tehdä kaiken yhdessä pätkässä. Git pull hakee ymmärtääkseni tiedot verkosta ja synkronoi ne paikallisen repon kanssa. 
`<$ git add . && git commit; git pull && git push>` Mardownn on githubissa kätevä, sillä muotoilu tapahtuu automaattisesti. Hiukan oli kuitenkin vaikeuksia saada esim linkki toimimaan (väärä määrä välilyöntejä ehkä?), ja koodimuotoon muotoilussa olivat hipsut vääränlaiset. Onneksi nanon käyttö on tuttua aiemmalta linux-kurssilta, joten sen osalta ei suurempia ihmettelemisiä syntynyt.

## b) Git Log, Git Diff, Git Blame
Nyt kun perustoiminallisuus oli kunnossa, kokeilin tehtävässä mainittuja komentoja. Hain hieman tukea jo valmiiksi internetistä, että osaisin hiukan arvioida mitä pitäisi tapahtua, lähteenä käytin lähinnä git.scm.com -sivun hakemistoa. Komennoista löytyy kuvia tästä git-reposta. 

Git Log ainakin kertoo sen, mitä muutoksia tiedostoon/ tiedostoihin on tehty, ja milloin. Se myös näyttää tekijän ja sähköpostiosoitteeni. 

Git Diff ei oikeastaan antanut mitään tulosta, kun kokeilin sitä. Yritin leikkiä sen tyhjän tiedoston kanssa ja asettaa se eri vaiheisiin add/commit -komennoilla, muttei vieläkään mitään. Päätin muokata tätä tiedostoa ja katsoa tapahtuisiko tämän osalta mitään -> sain lukemalla ennen mainittua sivua, että se voisi näyttää eron paikallisen ja verkkorepositorion välissä. Tästä tekstistä pitäisi siis tulla ilmoitus, jos teoriani on oikeassa. Tämä osoittautuikin todeksi, pienen testin jälkeen. Sen takia ensimmäinen yritykseni ei onnistunut, koska tiedosto jonka loin, ei koskaan ollut ollutkaan verkon repossa, jolloin tätä eroa (difference) ei voitukaan havaita. 

Git Blamen osalta lähdin ennakkoluulottomasti kokeilemaan komentoa, jolloin monta eri "lisävaihtoehtoa" ilmaantui. Näistä tajusin heti sen, että komennolle tuli määritellä jokin kohde, valitsin siis tämän tiedoston ja tarkastelin mitä tapahtui. Tästä näkeekin, kuka on tehnyt mitä ja mihin aikaan, myös versionumero löytyy ja itse commitille mitä ilmeisimmin jonkinlainen tunniste, joka tulee ihan ensimmäisenä. Ei commitoiduille muutoksille ei vielä kyseistä numeroa ole annettu, joka tarkoittanee sitä että kyseessä on itse commitin id, joka on sidottu tunnukseeni. Mielenkiintoisempaa olisikin nähdä miltä näyttäisi jos useampi ihminen olisi muokannut tiedostoa, tämähän sitten olisi versionhallintaa parhaimmillaan! Hieman vastaavanlaisia "merkintöjä" toki saa esim myös google docs:ista ulos, mutta ei lainkaan näin yksityiskohtaisesti. Käytössä tosin vain on tärkeää muistaa määritellä, mitä tiedostoa tarkastellaan. 

## c) Git Reset --hard

Seuraavaksi oli tarkoitus tarkistaa mitä Git reset tekee, jota varten ajattelin tehdä tekstitiedoston. Kuitenkin ihan ensimmäisenä commitoin ja pushaan tämän tiedoston muutokset, ettei mitään katoa! Koska tehtävänannossa lukee "älä tee commit:tia", niin lähdin siitä oletuksesta, että tiedosto pitää luoda, ja lisätä add komennolla odottamaan.  
Päätin olla melko ennakkoluuloton ja kokeilin tallennettuani kaikki tiedostot. Tein testitiedoston, jonka add:asin. Oletukseni oli, että se poistuisi add-jonosta ja palautuisi paikalliseen repoon, mutta tehtyäni resetin ja tarkistettuani, oli tiedosto kokonaan poissa, myös paikallisesta reposta. Kuvakaappauksesta näkee hakemiston tilan, joka on sama kuin kommentti jonka edeltävässä commitissa annoin, "viides".  Git status -komennolla tarkkailin sitä, mitä tiedostoja on vielä paikallisessa repossa odottamassa commitoimista. Jäin miettimään asiaa, ja kokeilin uudestaan, luomalla ns roskatiedoston. En kokeilut addia, vaan reseteon heti. Tiedosto jäi jäljelle, kun listasin hakemiston tiedostot. Sen jälkeen lisäsin sen add-komennolla, ja vielä lopuksi sitten resetoin, niin se katosi. Tavallaan kun ajattelee, on ihan loogista, mutta ennakkoon en uskonut tiedosotn katoavan paikallisesta reposta "vain" sen takia että se oli add:illa lisätty ennen toimintoa.  
 
## d) Uuden moduulin asennus

Tässä tehtävässä jatkettiin kertaamista. Päätin kokeilla asentaa Chromium-selaimen salt:ia hyväksikäyttäen. Prosessi seurasi melko pitkälti samaa kaavaa kuin aiemmin. Latasin aluksi "sudo apt-get" komennolla chromiumin manuaalisesti, ja tarkistin sen toimivan molemmilla virtuaalikoneilla. Tämän jälkeen testasin saltin toimivuuden, ja koska työskentelin samoilla koneilla kuin ennen, ajoin oman versioni "hei maailmasta" varmistaakseni, että yhteys toimi kuten sen piti. Ja se toimi. Poistin chromiumin minionilta, ja loin uuden chromium-nimisen kansion mkdir-komennolla. Tänne loin init.sls -tiedoston, jonne ensimmäisessä vaihessa loin vain pkg.installed -osion. Sen jälkeen aloin etsimään find:illä mistä chromiumin löytäisi. Ensiksi en meinannut löytää mitään, ja vasta kun ymmärsin etsiä sitä chromium-browser nimellä, sen kansio löytyi (kuten odotettu) etc-hakemistosta. En kuitenkaan löytänyt oikein mitään varsinaista configuraatiotiedostoa, mutta pienen googlailun jälkeen sain sen käsityksen, että default-tiedosto olisi lähinnä tätä, koska sitä voi erilaisin parametrein muokata. Päätin siis copioida sen sudo cp -komennolla /srv/salt/chromium -hakemistoon. 
