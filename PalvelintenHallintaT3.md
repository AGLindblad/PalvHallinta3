# *Palvelinten hallinta tehtävä 3. Versionhallinta, markdown,  salt*

## a) Git ja Markdown
Tässä tehtävässä oli määrä harjoitella paitsi markdownin käyttöä myös versionhallintaa gitin ja githubin avulla. Githubista on hieman kokemusta, lähinnä tietokantakurssilta, markdownista ei oikeastaan kokoemusta ole. Tehtävässä päästiin tavallaan alkuun jo tunnilla,
 kun kävimme läpi git:in peruskomentoja, ja katsoimme alustavasti githubia. Itseltäni löytyikin jo valmiiksi github tili, johon loin repositorion tätä tehtävää varten. Ohjeita tehtävää varten katselin pääosin Tero Karvisen [sivuilta](http://terokarvinen.com/2016/publish-your-project-with-github/). ALkutoimenpiteissä seurasin sivun ohejita pilkulleen, mutta vaihdoin salansananmuistamisen ajan hieman pidemmäksi, komentona siis `<$ git config --global credential.helper "cache --timeout=7200">`, jossa 7200 = sekunnit jotka salasana on voimassa. Näiden tehtävien kuvat löytyvät githubista omina tiedostoinaan! 

Tärkää tässä on siis ymmärtää git:in perustoiminto. Itse tein siinä järjesteyksessä, että loin aluksi repositorion, jonka cloonasin git clone -komennolla omaan, Xubuntu kotikansiooni. Loin sinne tiedostot jotka halusin luoda, testitiedoston, ja tämän palautustiedoston .md päätteiillä, jotta github tunnistaa nämä markdown -muotoiluiksi. Kun muutokset on tehty, ne lisätään ikäänkuin jonoon git add komennolla, git commit vahvistaa että haluan lähettää tiedostot. Tiedostot ovat kuitenkin toistaiseksi vain paikallisesti taltioitu. Git push komennon antaminen syöttää tiedostot verkkoon, sen jälkeen kun on syöttänyt tunnuksensa. Sivuilta löytyikin ritiramssu sitä varalta, että haluaa tehdä kaiken yhdessä pätkässä. Git pull hakee ymmärtääkseni tiedot verkosta ja synkronoi ne paikallisen repon kanssa. 
`<$ git add . && git commit; git pull && git push>` Markdown on githubissa kätevä, sillä muotoilu tapahtuu automaattisesti. Hiukan oli kuitenkin vaikeuksia saada esim linkki toimimaan (väärä määrä välilyöntejä ehkä?), ja koodimuotoon muotoilussa olivat hipsut vääränlaiset. Onneksi nanon käyttö on tuttua aiemmalta linux-kurssilta, joten sen osalta ei suurempia ihmettelemisiä syntynyt.

## b) Git Log, Git Diff, Git Blame
Nyt kun perustoiminallisuus oli kunnossa, kokeilin tehtävässä mainittuja komentoja. Hain hieman tukea jo valmiiksi internetistä, että osaisin hiukan arvioida mitä pitäisi tapahtua, lähteenä käytin lähinnä git.scm.com -sivun hakemistoa. Komennoista löytyy kuvia tästä git-reposta. 

Git Log ainakin kertoo sen, mitä muutoksia tiedostoon/ tiedostoihin on tehty, ja milloin. Se myös näyttää tekijän ja sähköpostiosoitteeni. 

Git Diff ei oikeastaan antanut mitään tulosta, kun kokeilin sitä. Yritin leikkiä sen tyhjän tiedoston kanssa ja asettaa se eri vaiheisiin add/commit -komennoilla, muttei vieläkään mitään. Päätin muokata tätä tiedostoa ja katsoa tapahtuisiko tämän osalta mitään -> sain lukemalla edellä  mainittua sivua, että se voisi näyttää eron paikallisen ja verkkorepositorion välissä. Tästä tekstistä pitäisi siis tulla ilmoitus, jos teoriani on oikeassa. Tämä osoittautuikin todeksi, pienen testin jälkeen. Sen takia ensimmäinen yritykseni ei onnistunut, koska tiedosto jonka loin, ei koskaan ollut ollutkaan verkon repossa, jolloin tätä eroa (difference) ei voitukaan havaita. 

Git Blamen osalta lähdin ennakkoluulottomasti kokeilemaan komentoa, jolloin monta eri "lisävaihtoehtoa" ilmaantui. Näistä tajusin heti sen, että komennolle tuli määritellä jokin kohde, valitsin siis tämän tiedoston ja tarkastelin mitä tapahtui. Tästä näkeekin, kuka on tehnyt mitä ja mihin aikaan, myös versionumero löytyy ja itse commitille mitä ilmeisimmin jonkinlainen tunniste, joka tulee ihan ensimmäisenä. Ei-commitoiduille muutoksille ei vielä kyseistä numeroa ole annettu, joka tarkoittanee sitä että kyseessä on itse commitin id, joka on sidottu tunnukseeni. Mielenkiintoisempaa olisikin nähdä miltä näyttäisi jos useampi ihminen olisi muokannut tiedostoa, tämähän sitten olisi versionhallintaa parhaimmillaan! Hieman vastaavanlaisia "merkintöjä" toki saa esim myös google docs:ista ulos, mutta ei lainkaan näin yksityiskohtaisesti. Käytössä tosin vain on tärkeää muistaa määritellä, mitä tiedostoa tarkastellaan. 

## c) Git Reset --hard

Seuraavaksi oli tarkoitus tarkistaa mitä Git reset tekee, jota varten ajattelin tehdä tekstitiedoston. Kuitenkin ihan ensimmäisenä commitoin ja pushaan tämän tiedoston muutokset, ettei mitään katoa! Koska tehtävänannossa lukee "älä tee commit:tia", niin lähdin siitä oletuksesta, että tiedosto pitää luoda, ja lisätä add komennolla odottamaan.  
Päätin olla melko ennakkoluuloton ja kokeilin tallennettuani kaikki tiedostot. Tein testitiedoston, jonka add:asin. Oletukseni oli, että se poistuisi add-jonosta ja palautuisi paikalliseen repoon, mutta tehtyäni resetin ja tarkistettuani, oli tiedosto kokonaan poissa, myös paikallisesta reposta. Kuvakaappauksesta näkee hakemiston tilan, joka on sama kuin kommentti jonka edeltävässä commitissa annoin, "viides".  Git status -komennolla tarkkailin sitä, mitä tiedostoja on vielä paikallisessa repossa odottamassa commitoimista. Jäin miettimään asiaa, ja kokeilin uudestaan, luomalla ns roskatiedoston. En kokeilut addia, vaan reseteon heti. Tiedosto jäi jäljelle, kun listasin hakemiston tiedostot. Sen jälkeen lisäsin sen add-komennolla, ja vielä lopuksi sitten resetoin, niin se katosi. Tavallaan kun ajattelee, on ihan loogista, mutta ennakkoon en uskonut tiedosotn katoavan paikallisesta reposta "vain" sen takia että se oli add:illa lisätty ennen toimintoa.  
 
## d) Uuden moduulin asennus

Tässä tehtävässä jatkettiin kertaamista. Päätin kokeilla asentaa Chromium-selaimen salt:ia hyväksikäyttäen. Prosessi seurasi melko pitkälti samaa kaavaa kuin aiemmin. Latasin aluksi "sudo apt-get" komennolla chromiumin manuaalisesti, ja tarkistin sen toimivan molemmilla virtuaalikoneilla. Tämän jälkeen testasin saltin toimivuuden, ja koska työskentelin samoilla koneilla kuin ennen, ajoin oman versioni "hei maailmasta" varmistaakseni, että yhteys toimi kuten sen piti. Ja se toimi. Poistin chromiumin minionilta, ja loin uuden chromium-nimisen kansion mkdir-komennolla. Tänne loin init.sls -tiedoston, jonne ensimmäisessä vaihessa loin vain pkg.installed -osion.
 Sen jälkeen aloin etsimään find:illä mistä chromiumin löytäisi. Ensiksi en meinannut löytää mitään, ja vasta kun ymmärsin etsiä sitä chromium-browser nimellä, sen kansio löytyi (kuten odotettu) etc-hakemistosta. En kuitenkaan löytänyt oikein mitään varsinaista configuraatiotiedostoa, mutta pienen googlailun jälkeen sain sen käsityksen, että default-tiedosto olisi lähinnä tätä, koska sitä voi erilaisin parametrein muokata. Päätin siis copioida sen sudo cp -komennolla /srv/salt/chromium -hakemistoon. 

Tässä lähdin ehkä turhan itsevarmasti laittamaan jo file.managed komentoa init.sls tiedostoon, määritellen polun toisaalta alkuperäiseen default-tiedostoon ja myös /srv/salt/chromium -kansiossa olevaan. Tämän jälkeen testasin `<$ sudo salt 'samakone' state.apply chromium>` -komentoa. Testi ei aluksi onnistunut, vaan antoi virhekoodin. Tajusin sen perusteella, että olin taas unohtanut "-browser" osan nimestä init.sls -tiedoston sisällä , ja kirjoittanut pelkän chromiumin. Tämän korjattuani, kaikki toimi, ja chromium asentui kiltisti myös minioneille. Sen jälkeen kuitenkin ongelmat alkoivat, sillä yritin laittaa samaan default-tiedostoon watch-komentoa, mutta bash ilmoitti kerta toisensa jälkeen "service not available". Kokeilin viime viikon ssh-harjoituksen kanssa, ja siinä kyllä watch toimi. Tein myös yksinkertaisinta mahdollisinta debuggausta ja kirjoitin tahallaan väärin YAMLin, ja virhetieto muuttui. Kirjoitin YAMLin kahdesti uudestaan, ihan varmuuden vuoksi. Katsoin salt stackista, että myös pkg-muutoksia voi seurata, joten vaihdoin sen "pkg: chrmomium-browser", muttei sekään auttanut. Vaihdoin myös seurattavaa tiedostoa, ja toisaalta viittasin oletmattomaan tiedostoon, joka vuorostaan taas antoi eri virheen. Yli tunnin pähkäiltyäni en edelleenkään keksinyt mikä meni pieleen. Vaihtoehtoja on mielestäni muutama:

* watch ei ole yhteensopiva kaikkien ohjelmien, kuten chromiumin kanssa
* olen tehnyt oudon kirjoitusvirheen jossain, jota en pysty löytämään
* viittaan tiedostotyyppiin tai muotoon, jota watch ei tue. Saltstackin dokumentaatiosta päätellen, kaikki tiedostot olivat .conf, enkä sellaista tiedostoa chromiumille löytänyt. 

Johtopäätös on, että minun täytyy selvittää opettajalta lisää watch-toiminnosta. Aikaa harjoituksen tekemiseen meni noin neljä tuntia. Luin sitä varten ennakkoon noin kaksi tuntia. Chromiumin ongelmien selvittämiseen meni aikaa tämän lisäksi vielä yli tunti, voi olla että kaksikin. Olen kuitenkin tyytyväinen siihen, että markdown formaatti tuli tutuksi, sain hyvän kertauksen gittiin, ja ainakin asentaminen saltin kautta alkaa olla tuttua, vaikka watch hämmentää. Nanon käyttäminen tuntuu kohtalaisen hyvältä, mutta edelleen hiukan hämää, ettei kursoria voi hiirellä asettaa haluamalleen paikalle, ja autocorrectiin ja spellcheckiin tottuneena, voi olla että oikoluvusta huolimatta virheitäkin on useampi.  

EDIT1: TOtesin oikeastaan hieman ajatelleeni asiaa takaperin, ja selvitinkin [saltstackista] (https://docs.saltstack.com/en/latest/ref/states/all/salt.states.service.html) service.running toimintoa, enkä watch-toimintoa kuten aiemmin. Eli service.running liittyy demoneihin ja niiden jälleenkäynnistämiseen, eli toisin sanoen eipä sitä Chromiumilla siten mitään voikaan tulla. Asia täytynee vielä varmistaa tunnilla, vaikka näin jälkikäteen tilanne näyttääkin melko selvältä ja aiemmat teoriani hieman hatarilta. Päätin kuitenkin jättää ne harjoitukseen, kognitiivsen prosessin illustroimiseksi. Saltin sivuilla lukeekin kyllä, että services = system daemons, ja komento jota yritin seurata  on nimeltään  service.running, joten eiköhä syy siihen, ettei yrittämäni kikkailu Chromiumin kanssa onnistunut ole melko selvä.  Hyvä esimerkki siitä, että kysymykset herää usein vasta sen jälkeen kun asioita on tehnyt, eikä luennolla, vaikka kysymyksiä pyydettiinkin jo silloin kysymään.  
